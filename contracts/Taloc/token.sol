//regular erc1155 

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol";
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol";
import "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";

/// @custom:security-contact info@taloc.io
contract Taloc is ERC1155, AccessControl, Pausable, ERC1155Burnable, ERC1155Supply, ERC1155Holder {
    bytes32 public constant URI_SETTER_ROLE = keccak256("URI_SETTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    uint256 public constant Taloc = 0;

//wont be able to declare NFT value's on deployment, only erc20's , becuase token ID needs to be known already, and reality is we will have millions of tokens ID's. the token ID will need to be generated randomly, each property will have a unique number

    //example 1 
    // this will need to be added on demand - "001" will need to be generated by chainlink VRF and appended from a function with .push   
    uint256 public constant Property_001 = 1;
    uint256 public constant Property_002 = 2;

    //or 

    //Example 2 -
    //property ID & Token ID are dynamic arrays generated from chainlink VRF and mapped togther
    // Declaring 2 dynamic arrays called "Token_ID" and "property_ID"  
     uint256[] public constant Property_ID;
     uint256[] public constant Token_ID; 
     mapping(Property_ID => Token_ID) public PropertytoTokens; 
     mapping (address => PropertytoTokens) public NFT_Owners; 

     //or 

     //Example 3 
     //declaring a struct with token id and property ID , then mapping that to owners address 

     struct Taloc_NFTS {
        uint256 Property_ID;
        uint256 Token_ID;
     }
     mapping (address => Taloc_NFTS) public NFT_Owners; 



    constructor() ERC1155("taloc.io") {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(URI_SETTER_ROLE, msg.sender);
        _grantRole(PAUSER_ROLE, msg.sender);
        _grantRole(MINTER_ROLE, msg.sender);
        
        //need to change ms.sender to taloc trust (multi sig address)
        //also need to send to myself (ms.sender) do i first mint totla suppply then transfer from taloc to me ? or is there a way to split this on the constructor
        _mint(msg.sender, Taloc, 1000000*10**18, "");
    
  
    }
    
    //will need to figure out how to mint NFT's on demand, { ex: mint when user loads deed into IFPS} (((see mint.sol)))
    //will also need to figure out how to fractionalize that one NFT value at the time of mint (perhaps semi fungible tokens ? )

        function gePropertyVRF () {
        
         //will be listening for event webhook on the FE, when user "uploads propery deed"
            event.listening (upload);

            //then will make a call to return chainlink VRF 
            return (memory uint256 property_VRF)
            //then trigger 'addDataPropertyID' function to push new # to property_ID array 
        }

        function getTokenVRF () {
            
            //will be listening for event webhook on the FE, when user "uploads propery deed"
                event.listening (upload);

            //then will make a call to return chainlink VRF 
            return (memory uint256 token_VRF)
            //then trigger 'addDataTokenID' function to push to token_ID array 
        }

        function addDataPropertyID(int num) public {
            Property_ID.push(num);
        }


        function addDataTokenID(int num) public {
            Token_ID.push(num);
        }


        function mint_on_demand (uint256 token_VRF) {
            //
            mint (address account, uint256 id, uint256 amount, bytes memory data);
        
        
        }

--------------------------------------

    function setURI(string memory newuri) public onlyRole(URI_SETTER_ROLE) {
        _setURI(newuri);
    }

    function pause() public onlyRole(PAUSER_ROLE) {
        _pause();
    }
    function unpause() public onlyRole(PAUSER_ROLE) {
        _unpause();
    }

    function mint(address account, uint256 id, uint256 amount, bytes memory data)
        public
        onlyRole(MINTER_ROLE)
    {
        _mint(account, id, amount, data);
    }

    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data)
        public
        onlyRole(MINTER_ROLE)
    {
        _mintBatch(to, ids, amounts, data);
    }

    // restrict transfer - can be used to meet condition before a token is transfered 
    function _beforeTokenTransfer(address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data)
        internal
        whenNotPaused
        override(ERC1155, ERC1155Supply)
    {
        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);
    }



    // https://docs.openzeppelin.com/contracts/4.x/api/token/erc1155#ERC1155 

    function balanceOf(account, id) {}

    function balanceOfBatch(accounts, ids) {}

    function setApprovalForAll(operator, approved) {}

    function isApprovedForAll(account, operator) {}

    //may revert if recipient has not registered itself as aware of the ERC1155 protocol, 
    //so transfers to it are disabled to prevent tokens from being locked forever.
    function safeTransferFrom(from, to, id, amount, data) {}

    function safeBatchTransferFrom(from, to, ids, amounts, data) {}

    function _safeTransferFrom(from, to, id, amount, data) {}

    function _safeBatchTransferFrom(from, to, ids, amounts, data) {}

    function _burn(from, id, amount) {}

    function _burnBatch(from, ids, amounts) {}

    function _setApprovalForAll(owner, operator, approved) {}

    function _afterTokenTransfer(operator, from, to, ids, amounts, data) {}

    function uri(_) {}

    event TransferSingle(operator, from, to, id, value) {}

    event TransferBatch(operator, from, to, ids, values) {}

    event ApprovalForAll(account, operator, approved) {}

    event URI(value, id) {}



    //https://docs.openzeppelin.com/contracts/4.x/api/token/erc1155#ERC1155Pausable 

    function _requireNotPaused () {}

    function _requirePaused () {}

    function paused () {}

    event Paused(account) {}

    event Unpaused(account) {}


   
   //https://docs.openzeppelin.com/contracts/4.x/api/token/erc1155#ERC1155Supply 

    function totalSupply(id) {}

    function exists(id) {}
 

 //https://docs.openzeppelin.com/contracts/3.x/api/token/erc1155#ERC1155Holder
 //In order for our contract to receive ERC1155 tokens,
 // we can inherit from the ERC1155Holder contract which handles the registering for us
 //IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be stuck.

    function onERC1155Received(_, _, _, _, _) {}

    function onERC1155BatchReceived(_, _, _, _, _) {}


    // The following functions are overrides required by Solidity.

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC1155, AccessControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    } 
}